# Owned vs. Shared Objects in Move

A cornerstone of Move on IOTA is the distinction between owned objects and shared objects. These refer to how data (objects) on the ledger can be accessed and by whom, which in turn affects performance and use cases:

#### Owned Objects 
An owned object has a single owner (typically an account address). Only transactions signed by that owner can read or write that object ￼. The benefit is that operations on owned objects can often bypass the global consensus process, resulting in very low latency to finality ￼. In IOTA’s MoveVM, if a transaction touches only owned objects of the sender, it can be executed quickly and in parallel, since no other party could be concurrently modifying those objects. This makes owned objects ideal for assets or data that only one user needs to control (for example, a user’s personal token balance object). The drawback is limited flexibility: only the owner can interact with that object directly, so any multi-party logic (like a trade between two users) must be coordinated through separate steps or off-chain agreements if only owned objects are used ￼.
	
#### Shared object
A shared object is one that is not tied to a single owner, meaning anyone can potentially read or invoke its functions (writes still have to follow rules in the contract) ￼. Shared objects enable multiple parties to interact with the same on-chain entity (for example, a shared fund pool or a game world state) without one designated owner. The trade-off is that transactions involving shared objects require consensus, because the platform must ensure consistency when many actors can invoke changes ￼. This adds slightly higher gas costs and latency to those transactions ￼. If a particular shared object becomes very popular (so-called “hot” object), there may be contention as many transactions try to touch it, which can increase latency due to the need for ordering. Despite the performance cost, shared objects are powerful for designing dApps that need trustless interaction between users. For example, an escrow smart contract could be a shared object that two parties send their assets into – the shared escrow holds assets from both until conditions are met. In fact, IOTA’s documentation provides an escrow example implemented once with only owned objects and once with a shared object to illustrate these trade-offs ￼.

In summary, use owned objects for private, high-throughput operations (one user’s data, e.g. your wallet’s coins) and use shared objects for collaborative or public-state scenarios (contracts or resources that many users will call). IOTA Move developers can choose the model per object to balance speed versus flexibility. This is a distinct feature compared to Ethereum, where essentially all contract state is “shared” (anyone can call a contract function) which necessitates every transaction going through consensus. In IOTA’s MoveVM, by carefully using owned objects one can achieve higher performance while still allowing shared-state logic where needed.